<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rust | Ramblin's]]></title>
  <link href="http://cmr.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://cmr.github.io/"/>
  <updated>2013-11-09T14:41:54-05:00</updated>
  <id>http://cmr.github.io/</id>
  <author>
    <name><![CDATA[Corey Richardson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[These Weeks in Rust]]></title>
    <link href="http://cmr.github.io/blog/2013/11/09/these-weeks-in-rust/"/>
    <updated>2013-11-09T05:21:00-05:00</updated>
    <id>http://cmr.github.io/blog/2013/11/09/these-weeks-in-rust</id>
    <content type="html"><![CDATA[<p>Welcome to a mega-<em>This Week in Rust</em>. I was swamped this past week with
schoolwork, so TWiR was put off. This week&rsquo;s combines the past two weeks of
progress. These past two weeks were fairly exciting in terms of language and
library progress. The next few weeks should be even more exciting.</p>

<!-- more -->


<h1>What&rsquo;s cooking on master?</h1>

<p>There were 108 PRs merged these past two weeks.</p>

<h2>Breaking Changes</h2>

<ul>
<li>The very long-awaited <a href="https://github.com/mozilla/rust/pull/9613">enum discriminant size
patch</a> has landed. This will
affect FFI. Size of enum discriminant is now configurable via the <code>repr</code>
attribute, and will by default shrink to the smallest needed.</li>
<li>The extension traits for <code>Reader</code> and <code>Writer</code> have <a href="https://github.com/mozilla/rust/pull/10079">been transformed into
default methods on their respective
trait</a>.</li>
<li>Non-string literals are now
<a href="https://github.com/mozilla/rust/pull/10166">disallowed</a> in attributes.</li>
<li>Type parameters are now
<a href="https://github.com/mozilla/rust/pull/10189">forbidden</a> on inner statics
(statics inside functions).</li>
<li>The interface to flush stdout <a href="https://github.com/mozilla/rust/pull/10218">has
changed</a>. It was previously
unsound by allowing aliased <code>&amp;mut</code>.</li>
<li><code>Result</code>&rsquo;s API has changed <a href="https://github.com/mozilla/rust/pull/10119">quite a
bit</a>, to be more consistent with
<code>Option</code>, and hopefully simpler.</li>
<li>Linker arguments <a href="https://github.com/mozilla/rust/pull/10199">no longer</a>
propagate across crates. This means that if you link to a crate, its linker
arguments won&rsquo;t be automatically added when your crate is linked.</li>
<li>The memory intrinsics <a href="https://github.com/mozilla/rust/pull/10251">have been
simplified</a>. A single intrinsic
for <code>memcpy</code>/<code>memmove</code>/<code>memset</code> is now exposed, rather than one per
    platform.</li>
<li><code>#[link(name = "...")]</code> is now <a href="https://github.com/mozilla/rust/pull/10260">taken into
account</a> by rustc when creating
build artifacts.</li>
<li><code>std::rt::io::file</code> <a href="https://github.com/mozilla/rust/pull/10179">has been fleshed out and
tweaked</a>. In particular, it has
been renamed to <code>std::rt::io::fs</code>, many previously-free functions are now
associated functions on <code>std::rt::io::File</code>, and <code>FileInfo</code> has been renamed
to <code>FileStat</code>.</li>
</ul>


<h2>Other Changes</h2>

<ul>
<li>Calling variadic functions with the C FFI <a href="https://github.com/mozilla/rust/pull/10064">is now
implemented</a>. This is a pretty
sweet change. The only thing missing in our C FFI now is unions.</li>
<li>We <a href="https://github.com/mozilla/rust/pull/10243">now have</a> octal numeric
literals, for all your esoteric numeric needs!</li>
<li>An <code>Any</code> type <a href="https://github.com/mozilla/rust/pull/9967">has been added</a>,
and it is now possible to retrieve the object a task failed with. Previously
tasks could only fail with a string, now they can fail with anything.</li>
<li>A <code>concat!</code> syntax extension <a href="https://github.com/mozilla/rust/pull/9740">has been
added</a> for compile-time string
concatenation.</li>
<li>Timers are <a href="https://github.com/mozilla/rust/pull/10083">now also ports</a>, and
the creator of a timer can cancel it.</li>
<li>As the first part of closure reform, <code>proc</code> is <a href="https://github.com/mozilla/rust/pull/10132">now sugar</a> for <code>~once
fn</code>, and <code>|A| -&gt; B</code> (and <code>fn(A) -&gt; B</code> for bare functions) <a href="https://github.com/mozilla/rust/pull/10187">are now
allowed</a> in types.</li>
<li>The section in the tutorial on vectors and strings <a href="https://github.com/mozilla/rust/pull/10354">has been
rewritten</a> for correctness with
modern Rust.</li>
<li>A bunch of C++ has been removed and rewritten. <a href="https://github.com/mozilla/rust/pull/10290">Thread
creation</a>, <a href="https://github.com/mozilla/rust/pull/10094">memory
regions</a> (used for debugging and
<code>@</code>-boxes, from what I can tell), and an <a href="https://github.com/mozilla/rust/pull/10163/files">unused
<code>array_list</code></a>.</li>
<li>Bounds check failures are <a href="https://github.com/mozilla/rust/pull/10113">now marked as a cold
path</a>, and a <code>cold</code> <a href="https://github.com/mozilla/rust/pull/10127">function
attribute</a> has been added.</li>
<li>The build system <a href="https://github.com/mozilla/rust/pull/10203">can cross-compile to iOS
now</a>, even though Rust doesn&rsquo;t
actually run on that platform (yet!).</li>
<li><code>std::rand</code> <a href="https://github.com/mozilla/rust/pull/10223">now implements the Gamma
distribution</a>.</li>
<li>Cross-crate destructor inlining <a href="https://github.com/mozilla/rust/pull/10242">now
works</a>.</li>
<li>A <code>type_id</code> intrinsic <a href="https://github.com/mozilla/rust/pull/10182">has been
added</a>.</li>
<li>Everything in the runtime that uses <code>libuv</code> has been <a href="https://github.com/mozilla/rust/pull/10058">split into its own
crate</a>. This means that the
runtime really is pluggable: you can implement your own event loop and so
forth.</li>
</ul>


<h2>New Contributors</h2>

<p>Welcome to our new contributors!</p>

<ul>
<li>Brian</li>
<li>Carol Willing</li>
<li>Dirkjan Bussink</li>
<li>Guillaume Pinot</li>
<li>Gyorgy Andrasek</li>
<li>Joshua Yanovski</li>
<li>Mat Carberry</li>
<li>Noufal Ibrahim</li>
<li>Robert Irelan</li>
<li>Tomas Sedovic</li>
<li>Jennifer Ward</li>
<li>Patrick Kim</li>
</ul>


<p>At .85 new contributors a day, we&rsquo;ll soon dwarf every other language in the
&ldquo;awesome volunteer&rdquo; category.</p>

<h1>Weekly Meetings</h1>

<p>Last week&rsquo;s
<a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-10-29">meeting</a>
discussed segmented stacks (spoiler: <a href="https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html">they&rsquo;re not coming
back</a> )
and placement new (we want it, how do we want it?).</p>

<p>This week&rsquo;s
<a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-11-05">meeting</a>
discussed the future of libextra, more stack things, octal literals, vector
representation, and temporary (&ldquo;rvalue&rdquo;) lifetimes.</p>

<h1>Announcements etc</h1>

<ul>
<li><strong>Reminder from <del>the Ministry of Truth</del> ChrisMorgan</strong>: Rust is awesome.</li>
<li>Rust Skåne, <a href="http://www.foocafe.org/event/a-friendly-introduction-to-rust">has an event page
now</a>. It will
be December 3 at 17:30 in Foo Cafe.</li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/">Integermingled Parameter
Lists</a>,
and <a href="http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/">take
2</a>.</li>
<li><a href="https://github.com/haxney/speculate">speculate</a> &ndash; a parallel speculative
execution library.</li>
<li><a href="https://github.com/luqmana/mcchat">mcchat</a> &ndash; a pure-Rust Minecraft chat
client.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More On Stack Safety]]></title>
    <link href="http://cmr.github.io/blog/2013/10/28/more-on-stack-safety/"/>
    <updated>2013-10-28T17:58:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/28/more-on-stack-safety</id>
    <content type="html"><![CDATA[<p>I got a lot of great feedback on my <a href="http://cmr.github.io/blog/2013/10/21/on-stack-safety/">previous
post</a>, and I&rsquo;ve done
some thinking and come up with what I think is a better proposal, and a solid
way forward.</p>

<!-- more -->


<ol>
<li>Teach the task API to allow spawning a task with a fixed stack size.</li>
<li>Add the ability to query stack size from LLVM. This lets us implement stack
guard zones precisely.</li>
<li>Add a way to use the result of #2 in a clean way. This is probably the
trickiest to get right.</li>
</ol>


<p>You&rsquo;ll note that this doesn&rsquo;t seem to support segmented stacks <em>or</em> omission
of stack safety! I&rsquo;m now of the opinion that segmented stacks have no future.
They currently only allow aborting on stack overflow, not unwinding, and their
only other benefit (the ability to &ldquo;grow&rdquo; the stack) is niche. If someone
really thinks growable stacks is desirable, and has valid, convincing
usecases, they should contact me by email or IRC.  Otherwise, the guarantees
they provide are the same as guard zones (abort on overflow).</p>

<p>Omission of stack safety seems missing. But, it isn&rsquo;t needed when using guard
zones! Since guard zones impose nothing on a function&rsquo;s generated code (ie,
there&rsquo;s no prelude that looks into TLS, no need for a <code>__morestack</code>), an
environment which can&rsquo;t provide guard zones simply does nothing special when
setting up a task&rsquo;s stack.</p>

<p>You&rsquo;ll also note that this ditches the static analysis I was so fond of. This
sort of analysis really belongs in a lint pass, rather than as a core part of
the safety feature. A crate can say <code>#[max_stack_size = "64K"];</code> or
<code>#[deny(unbounded_stack)]</code> if it wants static stack size checking (which
people
<a href="http://www.reddit.com/r/rust/comments/1owhwi/on_stack_safety/ccwke1l">seem</a>
<a href="http://www.reddit.com/r/rust/comments/1owhwi/on_stack_safety/ccwjhpn">to</a>
<a href="http://www.reddit.com/r/programming/comments/1owjmi/on_stack_safety_in_rust/ccwei0c">want</a>).</p>

<p>Requiring fixed-sized stacks seems like a step backwards, but I don&rsquo;t see a
better path forward. Solving this problem can be left to a less-rusty, perhaps
research, language.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[This Week in Rust]]></title>
    <link href="http://cmr.github.io/blog/2013/10/28/this-week-in-rust/"/>
    <updated>2013-10-28T16:20:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/28/this-week-in-rust</id>
    <content type="html"><![CDATA[<p>Welcome to another issue of <em>This Week in Rust!</em> This week marks the addition
of some more feature gates, removal of <code>std::io</code>, and some feature proposals.</p>

<!-- more -->


<h1>What&rsquo;s cooking on master?</h1>

<p>47 PRs were merged this week, and we passed issue number 10000.</p>

<h2>Breaking Changes</h2>

<ul>
<li>Most of the crypto in the stdlib <a href="https://github.com/mozilla/rust/pull/9744">has been
removed</a>.</li>
<li><code>std::io</code> <a href="https://github.com/mozilla/rust/pull/9901">has been removed</a>,
with corresponding improvements in <code>std::rt::io</code>.</li>
<li>The <code>frame_address</code> intrinsic <a href="https://github.com/mozilla/rust/pull/10040">has been
removed</a>.</li>
<li><code>@</code>-ptrs are <a href="https://github.com/mozilla/rust/pull/9923">now feature-gated</a>,
reflecting the fact that they will exist in a very different form once they
are finished.</li>
<li>All of the logging that used <code>fmt</code> (<code>debug!</code> and so forth) <a href="https://github.com/mozilla/rust/pull/10006">have been
transitioned to <code>format!</code></a>.</li>
<li><code>asm!</code> <a href="https://github.com/mozilla/rust/pull/10009">is also featured gated</a>.</li>
<li><code>sys::log_str</code> <a href="https://github.com/mozilla/rust/pull/9937">has moved</a>.</li>
</ul>


<h2>Other changes</h2>

<ul>
<li>The long-awaited addition of <code>mut</code> in patterns <a href="https://github.com/mozilla/rust/pull/10026">has finally
happened</a>. <code>let (mut x, y) = (1,
2);</code> works.</li>
<li>The scheduler now uses <a href="https://github.com/mozilla/rust/pull/10080">lock free data
structures</a>, which are supposed
to perform much better.</li>
<li>The homing code <a href="https://github.com/mozilla/rust/pull/10070">now does less
work</a>, which does one third as
many <code>write</code>&rsquo;s.</li>
<li><code>stdout</code> <a href="https://github.com/mozilla/rust/pull/10060">is now buffered</a>.</li>
<li>A <a href="https://github.com/mozilla/rust/pull/10054">non-libuv event loop</a> has
been added.</li>
<li><code>std::rand</code> has seen <a href="https://github.com/mozilla/rust/pull/9810">more</a>
<a href="https://github.com/mozilla/rust/pull/10015">work</a>.</li>
<li><code>rustpkg</code> <a href="https://github.com/mozilla/rust/pull/9654">now supports arbitrary
dependencies</a>, such as C
libraries.</li>
<li><code>mut</code> is <a href="https://github.com/mozilla/rust/pull/9989">now allowed on self</a>.</li>
<li>Nested comments <a href="https://github.com/mozilla/rust/pull/9936">are now
allowed</a>.</li>
<li><code>rustpkg</code> will now [find crates in the current directory], so you can say
<code>rustpkg build</code> in a source dir and it will build in a workspace.</li>
<li>Some new float intrinsics <a href="https://github.com/mozilla/rust/pull/9986">have been
exposed</a>.</li>
<li><code>println!</code> <a href="https://github.com/mozilla/rust/pull/9979">allocates less</a>.</li>
</ul>


<h2>New contributors</h2>

<ul>
<li>Igor Bukanov</li>
<li>Mark Rowe</li>
<li>Michael Letterle</li>
<li>reedlepee</li>
</ul>


<h1>Announcements etc</h1>

<ul>
<li>There will be a
<a href="http://www.meetup.com/Rust-Bay-Area/events/143439552/">meetup</a> in the San
Fransisco Mozilla office. Patrick Walton will be talking about sprocketnes.
If you&rsquo;re in the area, you should definitely go!</li>
<li><a href="http://hiho.io/rust-ci/">rust-ci</a> has been created, which lets you have
travis automatically rebuild and test your repo daily, to reduce
language/library breakage.</li>
<li><a href="https://github.com/erickt/rust-mustache">rust-mustache</a> and
<a href="https://github.com/erickt/rust-zmq">rust-zmq</a> have been updated for master.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1pdrv6/short_talk_about_rust_at_scalaio_in_paris_october/">Short talk about Rust at Scala.IO in Paris (October
25th)</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1pe2lc/a_bit_of_functional_programming_in_rust_or_a/">A Bit of Functional Programming in Rust, or A Misguided First Look at Rust
for ML
    Programmers</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1p52tj/a_draft_proposal_for_single_inheritance_in_rust/">A draft proposal for single
inheritance</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1p4vnk/iterators_yielding_mutable_references/">Iterators yielding mutable
references</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1p4qeh/servo_transitions_from_libcss_to_a_new_css/">Servo transitions from libcss to a new CSS library written in
Rust</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1owhwi/on_stack_safety/">On stack
safety</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Stack Safety]]></title>
    <link href="http://cmr.github.io/blog/2013/10/21/on-stack-safety/"/>
    <updated>2013-10-21T00:42:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/21/on-stack-safety</id>
    <content type="html"><![CDATA[<p>Stack safety is a sticky topic in Rust right now. There are multiple
conflicting tensions. My goal is to lay them bare, untangle the mess, and see
if there&rsquo;s a better way forward (spoiler: there is!).</p>

<!-- more -->


<p>When a program is &ldquo;stack safe&rdquo;, the <a href="http://en.wikipedia.org/wiki/Call_stack#Structure">stack
pointer</a> never points
outside of allocated memory specifically dedicated to the stack. The
most interesting violation of stack safety as it applies to Rust is the <a href="http://en.wikipedia.org/wiki/Stack_overflow">stack
overflow</a>. (In fact, given
safe code, or even unsafe code as long as it doesn&rsquo;t putz with the stack
pointer or the stack frame, it is the <em>only</em> possible violation of stack
safety). Stack overflow happens when the stack does not have enough space to
store the full stack frame.</p>

<p>There are three basic ways of dealing with stack overflow:</p>

<ol>
<li>Give up and accept the potential memory unsafety and resulting bugs.</li>
<li>Do static analysis to determine the maximum stack size, and make sure
that the stack is at least that large.</li>
<li>Do runtime checks to make sure that there is always enough space on the
stack for a function to proceed, and handle violation of that condition
somehow.</li>
</ol>


<p>(<em>Note</em>: in what follows, I conflate &ldquo;language&rdquo; with &ldquo;implementation of a
given language&rdquo; for clarity)</p>

<p>Examples of languages that take strategy #1 are C, C++, Nimrod, and
Objective-C. Stack overflow usually manifests as a segmentation fault or bus
error, though more colorful errors are possible when a thread runs into
another thread&rsquo;s stack, or onto the heap, causing heap corruption or threads
stomping on each others' stack. Clearly this is not a viable solution for
Rust: the very act of calling a function becomes unsafe.</p>

<p>Strategy #2 is tempting, but cannot be used in the general case. The
<a href="http://dl.acm.org/citation.cfm?id=1113833&amp;bnc=1">research</a>
<a href="http://dl.acm.org/citation.cfm?id=1631721">I</a>
<a href="http://dl.acm.org/citation.cfm?doid=1375634.1375656">found</a> investigate stack
depth in the case of no recursion (so the call graph is actually a call
(directed-)acyclic graph) but with asynchronous interrupt handlers. Indeed, it&rsquo;s
trivial to show that when recursion is disallowed, a conservative stack limit
can be calculated just by taking the longest path through the call graph with
the nodes being weighted by the size that function&rsquo;s stack frame needs (this
is a slightly different construction than most weighted graphs). This solution
is not viable either: recursion is perfectly valid, rejecting it would make
Rust very crippled as a language. To my knowledge, no languages rely on this
for stack safety, though in practice I am sure many applications apply this
technique.</p>

<p>This leaves us with strategy #3, dynamic checks. Dynamic checking is fairly
easy to do. The size of a function&rsquo;s stack frame is easy to calculate. One
need only increment/decrement some global (or, rather, thread-local) counter
by the stack frame size. When it becomes negative, there is no more stack.
Almost every language I&rsquo;ve used (the exceptions are noted above) use this
technique. Java, Python, Lua, Ruby, Go, the list goes on. The only differences
between the languages is what they do when the stack does overflow. Most throw
an exception. Another method of implementing dynamic checks is to leave a
&ldquo;guard zone&rdquo; after the stack. This zone is mapped in a way that accessing it
causes a page fault, which sends a signal or kills the process. (The exact
implementation of this strategy differs; some allocate a stack frame for a
function on the heap. Things get blurry with the interpreted languages, but
they generally prevent stack overflow in a memory safe way.)</p>

<p>Rust currently uses strategy #3, with tweaks. The current implementation
heavily depends on LLVM&rsquo;s <a href="http://llvm.org/releases/3.0/docs/SegmentedStacks.html">segmented
stack</a> feature. On x86
(and I assume other platforms as well), a pointer to the end of the stack is
stored in thread-local storage. The prelude to every function call compares
that value to the value of the stack pointer, and calls a special function
<code>__morestack</code> which will allocate a new stack segment for the function call to
take place on. The stack segment is freed afterwards. The kink comes when
using the FFI to call C code. C assumes a single, large stack. In order to
fulfill that expectation, we have the <code>fixed_stack_segment</code> attribute to
give a function a large stack segment: hopefully large enough that the C
function doesn&rsquo;t overflow the stack.</p>

<p>Segmented stacks are of questionable utility. On large systems, such as x64,
address space is practically boundless, so lazily allocating stack segments is
going to be slower than just requesting a very large mmap&rsquo;d stack that the OS
will lazily allocate. On small, resource-constrained systems, the overhead of
stack size checking (it requires TLS <em>and</em> stack size checks) is too much.
Segmented stacks only optimize for mid-sized address spaces. And the entire
purpose of segmented stacks (conservative but growable stack sizes) is moot if
one is not using many tasks with small stacks.
(<a href="https://mail.mozilla.org/pipermail/rust-dev/2013-July/004686.html">Previously</a>,
<a href="https://github.com/mozilla/rust/issues/8345">previously</a>)</p>

<p>All of the solutions so far are inadequate. They&rsquo;re inflexible and have poor
composability in the case where a crate wants custom stack safety. I propose a
hybrid:</p>

<ol>
<li>If there is no recursion or other sources of stack size uncertainty, the
maximum stack size is decidable and is used as the only stack size, like
strategy #2. Every function would be annotated with the total stack size it
could possibly use, given static function calls. This fails at the first
introduction of function pointers: it is impossible to know how much stack
they need until runtime. However, this is not as limiting as it may sound,
as long as one only tries to achieve a conservative estimate of maximum
stack size. Since function pointers only come from trait objects and
closures, the compiler can take the max of the stack frame for <em>every
implemention</em> of the trait. I would assume closures could work in a similar
way, in limited cases. There will always be cases where this analysis
fails.</li>
<li>If the analysis in step 1 results in indeterminate stack sizes, rustc will
check a crate attribute. This crate attribute indicates which stack safety
strategy should be used: either guard zones, stack size checks, segmented
stacks, or no stack safety at all (note that stack size checks is segmented
stacks minus expanding the stack with <code>__morestack</code>).  Disabling stack
safety &ldquo;taints&rdquo; a crate, and any use of its functions requires <code>unsafe</code>,
like calling C code, and they cannot be coerced to closures (this would
lose the &ldquo;taint&rdquo; bit). Note that when the maximum stack size is decidable,
this attribute won&rsquo;t be checked.</li>
</ol>


<p>All of the trickiness comes from compiling libraries with this. Executables
are easy: since they define the execution context, they can decide how they
want the stack to be secured. Libraries, being embedded in other contexts,
need to obey their execution environment. At the very least, no-stack-safety
will make it possible to implement libraries exposing a native ABI in Rust
without requiring weirdness in the FFI, as well as implement custom stack
safety when it&rsquo;s desired.</p>

<p>By allowing crates to chose how they want stack safety to be implemented, we
retain flexibility to fit any situation. By making it a crate attribute, we
can handle combination of crates using different stack safety schemes in a
sane way. There are still some niggling details with combining crates using
different stack safety schemes (propagating the taint bit is quite difficult
in the face of trait objects, but for now we could simply disallow
combinations and work them out later (it&rsquo;s a backwards compatible change). I
think this is a good stack safety strategy, superior to the current one, and
worth implementing.</p>

<p>Please email me any comments, or see the <a href="http://www.reddit.com/r/rust/comments/1owhwi/on_stack_safety/">discussion on
reddit</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[This Week in Rust]]></title>
    <link href="http://cmr.github.io/blog/2013/10/19/this-week-in-rust/"/>
    <updated>2013-10-19T10:49:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/19/this-week-in-rust</id>
    <content type="html"><![CDATA[<p>Welcome to another issue of <em>This Week in Rust</em>, a weekly summary of Rust&rsquo;s
progress and happenings in the community.</p>

<!-- more -->


<h1>What&rsquo;s cooking in master?</h1>

<p>48 PRs were merged this week.</p>

<h2>Breaking changes</h2>

<ul>
<li>Slices are now represented as <a href="https://github.com/mozilla/rust/pull/9885">number of elements, not number of
bytes</a>.</li>
<li><code>fmt!</code> has been <a href="https://github.com/mozilla/rust/pull/9919">completely
removed</a>.</li>
<li>Some fields in <code>std::comm</code> <a href="https://github.com/mozilla/rust/pull/9935">have been made
private</a>.</li>
<li><code>std::sys::refcount</code> <a href="https://github.com/mozilla/rust/pull/9922">has been
moved</a> to
<code>std::managed::refcount</code>.</li>
<li><a href="https://github.com/mozilla/rust/pull/9896/files#diff-69196c6d2488bf8d5b3471084e854407L22">A bunch of
functions</a>
have moved from <code>std::sys</code> to <code>std::mem</code>.</li>
<li><code>once fn</code> is <a href="https://github.com/mozilla/rust/pull/9863">now a feature gate</a>
rather than a <code>-Z</code> flag.</li>
<li><code>Path</code> has been <a href="https://github.com/mozilla/rust/pull/9655">completely
rewritten</a>.</li>
<li><code>extra::flatpipes</code> <a href="https://github.com/mozilla/rust/pull/9886">has been
removed</a>.</li>
</ul>


<h2>Other changes</h2>

<ul>
<li><code>jemalloc</code> has been <a href="https://github.com/mozilla/rust/pull/9933">removed from the
runtime</a>. The <a href="https://github.com/mozilla/rust/issues/9925">associated
issue</a> is quite scary.</li>
<li><code>rustdoc</code> <a href="https://github.com/mozilla/rust/pull/9946">struct field
visibility</a> is now corrected (it
stripped fields where it should not have).</li>
<li><code>rustdoc</code> also <a href="https://github.com/mozilla/rust/pull/9941">uses the actual privacy
rules</a> to strip methods.</li>
<li><code>format!</code> now gives <a href="https://github.com/mozilla/rust/pull/9932">much better</a>
error messages for invalid format strings.</li>
<li>The <code>fmt::Default</code> trait, used for default formatting with <code>format!</code>, is
<a href="https://github.com/mozilla/rust/pull/9938">now documented</a>.</li>
<li><code>include_bin!</code> has been optimized, and the <code>k-nucleotides</code> benchmark now
compiles <a href="https://github.com/mozilla/rust/pull/9851">187x faster</a>.</li>
<li>Vectors now have <a href="https://github.com/mozilla/rust/pull/9907"><code>starts_with</code> and <code>ends_with</code>
methods</a>, which take slices.</li>
<li>An <code>abort</code> intrinsic <a href="https://github.com/mozilla/rust/pull/9860">has been
added</a>.</li>
<li>Vectors now have a <a href="https://github.com/mozilla/rust/pull/9608"><code>get_opt</code>
method</a>.</li>
</ul>


<h2>New contributors</h2>

<p>A new section for new contributors! The new contributors this week are (as
reported by git):</p>

<ul>
<li>Chris Sainty</li>
<li>Eduard Burtescu</li>
<li>Erik Lyon</li>
<li>Harry Marr</li>
<li>Sébastien Chauvel</li>
<li>Vijay Korapaty</li>
<li>Ziad Hatahet</li>
<li>chitra</li>
</ul>


<h1>Weekly Meeting</h1>

<p>The <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-10-15">weekly
meeting</a>
discussed removing rusti, changing the attribute syntax, destructors in
statics, and more multi-crate packages with rustpkg.</p>

<h1>Announcements etc</h1>

<ul>
<li>Rust (and Servo) are participating in the <a href="https://groups.google.com/forum/#!topic/mozilla.dev.servo/7kX_E0FlfkA">GNOME Outreach Program for
Women</a>.
A bunch of people have already come into IRC about it.</li>
<li><a href="http://exercism.io">http://exercism.io</a> <a href="https://github.com/kytrinyx/exercism.io/pull/866">is getting full Rust
support</a>. This is a very
cool resource, and could help a lot getting newcomers acclimated.</li>
<li><a href="https://mail.mozilla.org/pipermail/rust-dev/2013-October/006034.html">Unified Function/method Call Syntax and further
simplification</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1osbq2/safe_manual_memory_management_in_cyclone_research/">Safe Memory Management in
Cyclone</a>.</li>
<li><a href="http://opensourcebridge.org/sessions/970">Audio</a> from Tim&rsquo;s talk in June is
finally available!</li>
<li>An
<a href="https://github.com/mozilla/rust/wiki/Operating-system-development">OSdev</a>
community has sprung up! The channel is <code>#rust-osdev</code>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1omw47/should_io_use_conditions/">Should I/O use
conditions?</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1opo36/pointers_in_rust_a_guide/">Pointers in Rust: A
Guide</a>.</li>
<li>I am on a <a href="http://cmr.github.io/blog/2013/10/14/rust-hiatus/">Rust hiatus</a>,
for the time being. TWiR will still be happening, as you are reading it
right now.</li>
<li><a href="https://github.com/thestinger/rust-core">rust-core</a> &ndash; A stub standard
library.</li>
</ul>

]]></content>
  </entry>
  
</feed>
